C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE SPIM
OBJECT MODULE PLACED IN .\DP8051_Keil_903\Debug\SPIM.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\2.1\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\SPIM.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051_Keil_903\Debug\SPIM.lst) CD DB NOIP OT(0,SIZE) 
                    -INCDIR(Generated_Source\PSoC3) OJ(.\DP8051_Keil_903\Debug\SPIM.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: SPIM.c
   3          * Version 2.30
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the SPI Master component.
   7          *
   8          * Note:
   9          *  None.
  10          *
  11          ********************************************************************************
  12          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  13          * You may use this file only in accordance with the license, terms, conditions, 
  14          * disclaimers, and limitations in the end user license agreement accompanying 
  15          * the software package with which this file was provided.
  16          *******************************************************************************/
  17          
  18          #include "CyLib.h"
  19          #include "SPIM.h"
  20          
  21          #if(SPIM_InternalClockUsed)
  22              #include "SPIM_IntClock.h"   
  23          #endif /* SPIM_InternalClockUsed */
  24          
  25          #if (SPIM_TXBUFFERSIZE > 4u)
              
                  volatile uint8 SPIM_TXBUFFER[SPIM_TXBUFFERSIZE] = {0u};
                  volatile uint8 SPIM_txBufferRead = 0u;
                  volatile uint8 SPIM_txBufferWrite = 0u;
                  volatile uint8 SPIM_txBufferFull = 0u;
                  
              #endif /* SPIM_TXBUFFERSIZE > 4u */
  33          
  34          #if (SPIM_RXBUFFERSIZE > 4u)
              
                  volatile uint8 SPIM_RXBUFFER[SPIM_RXBUFFERSIZE] = {0u};
                  volatile uint8 SPIM_rxBufferRead = 0u;
                  volatile uint8 SPIM_rxBufferWrite = 0u;
                  volatile uint8 SPIM_rxBufferFull = 0u;
                  
              #endif /* SPIM_RXBUFFERSIZE > 4u */
  42          
  43          uint8 SPIM_initVar = 0u;
  44          
  45          extern volatile uint8 SPIM_swStatusTx;
  46          extern volatile uint8 SPIM_swStatusRx;
  47          
  48          
  49          /*******************************************************************************
  50          * Function Name: SPIM_Init
  51          ********************************************************************************
  52          *
  53          * Summary:
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 2   

  54          *  Inits/Restores default SPIM configuration provided with customizer.
  55          *
  56          * Parameters:
  57          *  None.
  58          *
  59          * Return:
  60          *  None.
  61          *
  62          * Side Effects:
  63          *  When this function is called it initializes all of the necessary parameters
  64          *  for execution. i.e. setting the initial interrupt mask, configuring the 
  65          *  interrupt service routine, configuring the bit-counter parameters and 
  66          *  clearing the FIFO and Status Register.
  67          *
  68          * Reentrant:
  69          *  No.
  70          *
  71          *******************************************************************************/
  72          void SPIM_Init(void) 
  73          {    
  74   1          /* Initialize the Bit counter */
  75   1          SPIM_COUNTER_PERIOD_REG = SPIM_BITCTR_INIT;
  76   1          
  77   1          /* ISR initialization  */  
  78   1          #if(SPIM_InternalTxInterruptEnabled)
                  
                      CyIntDisable(SPIM_TX_ISR_NUMBER);
              
                      /* Set the ISR to point to the SPIM_isr Interrupt. */
                      CyIntSetVector(SPIM_TX_ISR_NUMBER, SPIM_TX_ISR);
              
                      /* Set the priority. */
                      CyIntSetPriority(SPIM_TX_ISR_NUMBER, SPIM_TX_ISR_PRIORITY);
                      
                  #endif /* SPIM_InternalTxInterruptEnabled */                                
  89   1          
  90   1          #if(SPIM_InternalRxInterruptEnabled)
                  
                      CyIntDisable(SPIM_RX_ISR_NUMBER);
              
                      /* Set the ISR to point to the SPIM_isr Interrupt. */
                      CyIntSetVector(SPIM_RX_ISR_NUMBER, SPIM_RX_ISR);
              
                      /* Set the priority. */
                      CyIntSetPriority(SPIM_RX_ISR_NUMBER, SPIM_RX_ISR_PRIORITY);
                      
                  #endif /* SPIM_InternalRxInterruptEnabled */
 101   1          
 102   1          /* Clear any stray data from the RX and TX FIFO */    
 103   1              SPIM_ClearFIFO();
 104   1              
 105   1              #if(SPIM_RXBUFFERSIZE > 4u)
                  
                      SPIM_rxBufferRead = 0u;
                      SPIM_rxBufferWrite = 0u;
              
                  #endif /* SPIM_RXBUFFERSIZE > 4u */
 111   1              
 112   1          #if(SPIM_TXBUFFERSIZE > 4u)
                  
                      SPIM_txBufferRead = 0u;
                      SPIM_txBufferWrite = 0u;
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 3   

              
                  #endif /* SPIM_TXBUFFERSIZE > 4u */
 118   1          
 119   1          (void) SPIM_ReadTxStatus(); /* Clear any pending status bits */
 120   1          (void) SPIM_ReadRxStatus(); /* Clear any pending status bits */
 121   1              
 122   1              /* Configure the Initial interrupt mask */
 123   1          #if (SPIM_TXBUFFERSIZE > 4u)
                      SPIM_TX_STATUS_MASK_REG  = SPIM_TX_INIT_INTERRUPTS_MASK & 
                                                              ~SPIM_STS_TX_FIFO_NOT_FULL;                    
                      #else /* SPIM_TXBUFFERSIZE < 4u */    
 127   1              SPIM_TX_STATUS_MASK_REG  = SPIM_TX_INIT_INTERRUPTS_MASK;       
 128   1              #endif /* SPIM_TXBUFFERSIZE > 4u */
 129   1          
 130   1          SPIM_RX_STATUS_MASK_REG  = SPIM_RX_INIT_INTERRUPTS_MASK; 
 131   1      }
 132            
 133              
 134          /*******************************************************************************
 135          * Function Name: SPIM_Enable
 136          ********************************************************************************
 137          *
 138          * Summary:
 139          *  Enable SPIM component.
 140          *
 141          * Parameters:
 142          *  None.
 143          *
 144          * Return:
 145          *  None.
 146          *
 147          *******************************************************************************/
 148          void SPIM_Enable(void) 
 149          {             
 150   1          uint8 enableInterrupts = 0u;    
 151   1          
 152   1          enableInterrupts = CyEnterCriticalSection();
 153   1          
 154   1          SPIM_COUNTER_CONTROL_REG |= SPIM_CNTR_ENABLE;
 155   1          SPIM_TX_STATUS_ACTL_REG |= SPIM_INT_ENABLE;
 156   1          SPIM_RX_STATUS_ACTL_REG |= SPIM_INT_ENABLE;
 157   1          
 158   1          CyExitCriticalSection(enableInterrupts);
 159   1          
 160   1          #if(SPIM_InternalClockUsed)    
 161   1              SPIM_IntClock_Enable();        
 162   1          #endif /* SPIM_InternalClockUsed */
 163   1          
 164   1          #if(SPIM_InternalTxInterruptEnabled)    
                      CyIntEnable(SPIM_TX_ISR_NUMBER);        
                  #endif /* SPIM_InternalTxInterruptEnabled */
 167   1          
 168   1          #if(SPIM_InternalRxInterruptEnabled)    
                      CyIntEnable(SPIM_RX_ISR_NUMBER);        
                  #endif /* SPIM_InternalRxInterruptEnabled */
 171   1      }
 172          
 173          
 174          /*******************************************************************************
 175          * Function Name: SPIM_Start
 176          ********************************************************************************
 177          *
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 4   

 178          * Summary:
 179          *  Initialize and Enable the SPI Master component.
 180          *
 181          * Parameters:
 182          *  None.
 183          *
 184          * Return:
 185          *  None.
 186          *
 187          * Global variables:
 188          *  SPIM_initVar - used to check initial configuration, modified on
 189          *  first function call.
 190          *
 191          * Theory:
 192          *  Enable the clock input to enable operation.
 193          *
 194          * Reentrant:
 195          *  No.
 196          *
 197          *******************************************************************************/
 198          void SPIM_Start(void) 
 199          {       
 200   1          if(SPIM_initVar == 0u)
 201   1          {               
 202   2              SPIM_Init();
 203   2              SPIM_initVar = 1u; 
 204   2          }                       
 205   1              
 206   1          SPIM_Enable();        
 207   1      }
 208          
 209          
 210          /*******************************************************************************
 211          * Function Name: SPIM_Stop
 212          ********************************************************************************
 213          *
 214          * Summary:
 215          *  Disable the SPI Master component.
 216          *
 217          * Parameters:
 218          *  None.
 219          *
 220          * Return:
 221          *  None.
 222          *
 223          * Theory:
 224          *  Disable the clock input to enable operation.
 225          *
 226          *******************************************************************************/
 227          void SPIM_Stop(void) 
 228          {
 229   1          uint8 enableInterrupts = 0u;    
 230   1          
 231   1          enableInterrupts = CyEnterCriticalSection();
 232   1          
 233   1          SPIM_TX_STATUS_ACTL_REG &= ~SPIM_INT_ENABLE;
 234   1          SPIM_RX_STATUS_ACTL_REG &= ~SPIM_INT_ENABLE;
 235   1          
 236   1          CyExitCriticalSection(enableInterrupts);
 237   1          
 238   1          #if(SPIM_InternalClockUsed)    
 239   1              SPIM_IntClock_Disable();        
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 5   

 240   1          #endif /* SPIM_InternalClockUsed */
 241   1          
 242   1          #if(SPIM_InternalTxInterruptEnabled)    
                      CyIntDisable(SPIM_TX_ISR_NUMBER);        
                  #endif /* SPIM_InternalTxInterruptEnabled */
 245   1          
 246   1          #if(SPIM_InternalRxInterruptEnabled)    
                      CyIntDisable(SPIM_RX_ISR_NUMBER);        
                  #endif /* SPIM_InternalRxInterruptEnabled */
 249   1      }
 250          
 251          
 252          /*******************************************************************************
 253          * Function Name: SPIM_EnableTxInt
 254          ********************************************************************************
 255          *
 256          * Summary:
 257          *  Enable internal Tx interrupt generation.
 258          *
 259          * Parameters:
 260          *  None.
 261          *
 262          * Return:
 263          *  None.
 264          *
 265          * Theory:
 266          *  Enable the internal Tx interrupt output -or- the interrupt component itself.
 267          *
 268          *******************************************************************************/
 269          void SPIM_EnableTxInt(void) 
 270          {       
 271   1          #if(SPIM_InternalTxInterruptEnabled)    
                      CyIntEnable(SPIM_TX_ISR_NUMBER);
                  #endif /* SPIM_InternalTxInterruptEnabled */     
 274   1      }
 275          
 276          
 277          /*******************************************************************************
 278          * Function Name: SPIM_EnableRxInt
 279          ********************************************************************************
 280          *
 281          * Summary:
 282          *  Enable internal Rx interrupt generation.
 283          *
 284          * Parameters:
 285          *  None.
 286          *
 287          * Return:
 288          *  None.
 289          *
 290          * Theory:
 291          *  Enable the internal Rx interrupt output -or- the interrupt component itself.
 292          *
 293          *******************************************************************************/
 294          void SPIM_EnableRxInt(void) 
 295          {       
 296   1          #if(SPIM_InternalRxInterruptEnabled)            
                      CyIntEnable(SPIM_RX_ISR_NUMBER);
                  #endif /* SPIM_InternalRxInterruptEnabled */     
 299   1      }
 300          
 301          
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 6   

 302          /*******************************************************************************
 303          * Function Name: SPIM_DisableTxInt
 304          ********************************************************************************
 305          *
 306          * Summary:
 307          *  Disable internal Tx interrupt generation.
 308          *
 309          * Parameters:
 310          *  None.
 311          *
 312          * Return:
 313          *  None.
 314          *
 315          * Theory:
 316          *  Disable the internal Tx interrupt output -or- the interrupt component itself.
 317          *
 318          *******************************************************************************/
 319          void SPIM_DisableTxInt(void) 
 320          {
 321   1          #if(SPIM_InternalTxInterruptEnabled)    
                      CyIntDisable(SPIM_TX_ISR_NUMBER);        
                  #endif /* SPIM_InternalTxInterruptEnabled */
 324   1      }
 325          
 326          
 327          /*******************************************************************************
 328          * Function Name: SPIM_DisableRxInt
 329          ********************************************************************************
 330          *
 331          * Summary:
 332          *  Disable internal Rx interrupt generation.
 333          *
 334          * Parameters:
 335          *  None.
 336          *
 337          * Return:
 338          *  None.
 339          *
 340          * Theory:
 341          *  Disable the internal Rx interrupt output -or- the interrupt component itself.
 342          *
 343          *******************************************************************************/
 344          void SPIM_DisableRxInt(void) 
 345          {
 346   1          #if(SPIM_InternalRxInterruptEnabled)    
                      CyIntDisable(SPIM_RX_ISR_NUMBER);        
                  #endif /* SPIM_InternalRxInterruptEnabled */
 349   1      }
 350          
 351          
 352          /*******************************************************************************
 353          * Function Name: SPIM_SetTxInterruptMode
 354          ********************************************************************************
 355          *
 356          * Summary:
 357          *  Configure which status bits trigger an interrupt event.
 358          *
 359          * Parameters:
 360          *  intSrc: An or'd combination of the desired status bit masks (defined in the 
 361          *  header file).
 362          *
 363          * Return:
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 7   

 364          *  None.
 365          *
 366          * Theory:
 367          *  Enables the output of specific status bits to the interrupt controller.
 368          *
 369          *******************************************************************************/
 370          void SPIM_SetTxInterruptMode(uint8 intSrc) 
 371          {
 372   1          SPIM_TX_STATUS_MASK_REG  = intSrc;    
 373   1      }
 374          
 375          
 376          /*******************************************************************************
 377          * Function Name: SPIM_SetRxInterruptMode
 378          ********************************************************************************
 379          *
 380          * Summary:
 381          *  Configure which status bits trigger an interrupt event.
 382          *
 383          * Parameters:
 384          *  intSrc: An or'd combination of the desired status bit masks (defined in the 
 385          *  header file).
 386          *
 387          * Return:
 388          *  None.
 389          *
 390          * Theory:
 391          *  Enables the output of specific status bits to the interrupt controller.
 392          *
 393          *******************************************************************************/
 394          void SPIM_SetRxInterruptMode(uint8 intSrc) 
 395          {
 396   1          SPIM_RX_STATUS_MASK_REG  = intSrc;
 397   1      }
 398          
 399          
 400          /*******************************************************************************
 401          * Function Name: SPIM_ReadTxStatus
 402          ********************************************************************************
 403          *
 404          * Summary:
 405          *  Read the Tx status register for the component.
 406          *
 407          * Parameters:
 408          *  None.
 409          *
 410          * Return:
 411          *  Contents of the Tx status register.
 412          *
 413          * Global variables:
 414          *  SPIM_swStatusTx - used to store in software status register, 
 415          *  modified every function call - resets to zero.
 416          *
 417          * Theory:
 418          *  Allows the user and the API to read the Tx status register for error
 419          *  detection and flow control.
 420          *
 421          * Side Effects:
 422          *  Clear Tx status register of the component.
 423          *
 424          * Reentrant:
 425          *  No.
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 8   

 426          *
 427          *******************************************************************************/
 428          uint8 SPIM_ReadTxStatus(void) 
 429          {
 430   1          uint8 tmpStatus = 0u;
 431   1              
 432   1          #if (SPIM_TXBUFFERSIZE > 4u)
                  
                      SPIM_DisableTxInt();
                      
                      tmpStatus = SPIM_GET_STATUS_TX(SPIM_swStatusTx);                    
                      
                      SPIM_swStatusTx = 0u;        
                      
                      /* Enable Interrupts */
                      SPIM_EnableTxInt();
                      
                  #else /* (SPIM_TXBUFFERSIZE < 4u) */
 444   1          
 445   1              tmpStatus = SPIM_TX_STATUS_REG;
 446   1              
 447   1          #endif /* (SPIM_TXBUFFERSIZE > 4u) */
 448   1          
 449   1          return(tmpStatus);
 450   1      }
 451          
 452          
 453          /*******************************************************************************
 454          * Function Name: SPIM_ReadRxStatus
 455          ********************************************************************************
 456          *
 457          * Summary:
 458          *  Read the Rx status register for the component.
 459          *
 460          * Parameters:
 461          *  None.
 462          *
 463          * Return:
 464          *  Contents of the Rx status register.
 465          *
 466          * Global variables:
 467          *  SPIM_swStatusRx - used to store in software Rx status register, 
 468          *  modified every function call - resets to zero.
 469          *
 470          * Theory:
 471          *  Allows the user and the API to read the Rx status register for error 
 472          *  detection and flow control.
 473          *
 474          * Side Effects:
 475          *  Clear Rx status register of the component.
 476          *
 477          * Reentrant:
 478          *  No.
 479          *
 480          *******************************************************************************/
 481          uint8 SPIM_ReadRxStatus(void) 
 482          {
 483   1          uint8 tmpStatus = 0u;
 484   1              
 485   1          #if (SPIM_RXBUFFERSIZE > 4u)
                  
                      SPIM_DisableRxInt();
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 9   

                      
                      tmpStatus = SPIM_GET_STATUS_RX(SPIM_swStatusRx);
                             
                      SPIM_swStatusRx = 0u;
                      
                      /* Enable Interrupts */
                      SPIM_EnableRxInt();
                      
                  #else /* (SPIM_RXBUFFERSIZE < 4u) */
 497   1          
 498   1              tmpStatus = SPIM_RX_STATUS_REG;
 499   1              
 500   1          #endif /* (SPIM_RXBUFFERSIZE > 4u) */
 501   1          
 502   1          return(tmpStatus);
 503   1      }
 504          
 505          
 506          /*******************************************************************************
 507          * Function Name: SPIM_WriteTxData
 508          ********************************************************************************
 509          *
 510          * Summary:
 511          *  Write a byte of data to be sent across the SPI.
 512          *
 513          * Parameters:
 514          *  txDataByte: The data value to send across the SPI.
 515          *
 516          * Return:
 517          *  None.
 518          *
 519          * Global variables:
 520          *  SPIM_txBufferWrite - used for the account of the bytes which
 521          *  have been written down in the TX software buffer, modified every function
 522          *  call if TX Software Buffer is used.
 523          *  SPIM_txBufferRead - used for the account of the bytes which
 524          *  have been read from the TX software buffer.
 525          *  SPIM_TXBUFFER[SPIM_TXBUFFERSIZE] - used to store
 526          *  data to sending, modified every function call if TX Software Buffer is used.
 527          *
 528          * Theory:
 529          *  Allows the user to transmit any byte of data in a single transfer.
 530          *
 531          * Side Effects:
 532          *  If this function is called again before the previous byte is finished then
 533          *  the next byte will be appended to the transfer with no time between
 534          *  the byte transfers. Clear Tx status register of the component.
 535          *
 536          * Reentrant:
 537          *  No.
 538          *
 539          *******************************************************************************/
 540          void SPIM_WriteTxData(uint8 txData) 
 541          {    
 542   1          #if(SPIM_TXBUFFERSIZE > 4u)
              
                      int16 tmpTxBufferRead = 0u;
                              
                      /* Block if buffer is full, so we don't overwrite. */
                      do
                      {
                          tmpTxBufferRead = SPIM_txBufferRead - 1u;
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 10  

                          if (tmpTxBufferRead < 0u)
                          {
                              tmpTxBufferRead = SPIM_TXBUFFERSIZE - 1u;        
                          }    
                      } while(tmpTxBufferRead == SPIM_txBufferWrite);               
                                 
                      /* Disable Interrupt to protect variables that could change on interrupt. */
                      SPIM_DisableTxInt();
                      
                      SPIM_swStatusTx = SPIM_GET_STATUS_TX(SPIM_swStatusTx);
                      
                      if((SPIM_txBufferRead == SPIM_txBufferWrite) &&
                          ((SPIM_swStatusTx & SPIM_STS_TX_FIFO_NOT_FULL) != 0u))
                      {
                          /* Add directly to the FIFO. */
                          CY_SET_REG8(SPIM_TXDATA_PTR, txData);
                      }
                      else
                      {
                          /* Add to the software buffer. */
                          SPIM_txBufferWrite++;
                          if(SPIM_txBufferWrite >= SPIM_TXBUFFERSIZE)
                          {
                              SPIM_txBufferWrite = 0u;
                          }   
                                    
                          if(SPIM_txBufferWrite == SPIM_txBufferRead)
                          {
                              SPIM_txBufferRead++;
                              if(SPIM_txBufferRead >= SPIM_RXBUFFERSIZE)
                              {
                                  SPIM_txBufferRead = 0u;
                              }
                              SPIM_txBufferFull = 1u;
                          }
                          
                          SPIM_TXBUFFER[SPIM_txBufferWrite] = txData;
                          
                          SPIM_TX_STATUS_MASK_REG |= SPIM_STS_TX_FIFO_NOT_FULL;            
                      }                         
                      
                      /* Enable Interrupt. */
                      SPIM_EnableTxInt();                        
              
                  #else /* SPIM_TXBUFFERSIZE <= 4u */
 595   1      
 596   1              /* Block while FIFO is full */
 597   1              while((SPIM_TX_STATUS_REG & SPIM_STS_TX_FIFO_NOT_FULL) == 0u);
 598   1              
 599   1              /* Then write the byte */
 600   1              CY_SET_REG8(SPIM_TXDATA_PTR, txData);
 601   1      
 602   1          #endif /* SPIM_TXBUFFERSIZE > 4u */
 603   1      }
 604          
 605          
 606          /*******************************************************************************
 607          * Function Name: SPIM_ReadRxData
 608          ********************************************************************************
 609          *
 610          * Summary:
 611          *  Read the next byte of data received across the SPI.
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 11  

 612          *
 613          * Parameters:
 614          *  None.
 615          *
 616          * Return:
 617          *  The next byte of data read from the FIFO.
 618          *
 619          * Global variables:
 620          *  SPIM_rxBufferWrite - used for the account of the bytes which
 621          *  have been written down in the RX software buffer.
 622          *  SPIM_rxBufferRead - used for the account of the bytes which
 623          *  have been read from the RX software buffer, modified every function
 624          *  call if RX Software Buffer is used.
 625          *  SPIM_RXBUFFER[SPIM_RXBUFFERSIZE] - used to store
 626          *  received data.
 627          *
 628          * Theory:
 629          *  Allows the user to read a byte of data received.
 630          *
 631          * Side Effects:
 632          *  Will return invalid data if the FIFO is empty. The user should Call 
 633          *  GetRxBufferSize() and if it returns a non-zero value then it is safe to call 
 634          *  ReadByte() function.
 635          *
 636          * Reentrant:
 637          *  No.
 638          *
 639          *******************************************************************************/
 640          uint8 SPIM_ReadRxData(void) 
 641          {
 642   1          uint8 rxData = 0u;
 643   1      
 644   1          #if(SPIM_RXBUFFERSIZE > 4u)
                  
                      /* Disable Interrupt to protect variables that could change on interrupt. */
                      SPIM_DisableRxInt();
                      
                      if(SPIM_rxBufferRead != SPIM_rxBufferWrite)
                      {      
                          if(SPIM_rxBufferFull == 0u)
                          {
                              SPIM_rxBufferRead++;
                              if(SPIM_rxBufferRead >= SPIM_RXBUFFERSIZE)
                              {
                                  SPIM_rxBufferRead = 0u;
                              }
                          }
                          else
                          {
                              SPIM_rxBufferFull = 0u;
                          }
                      }    
                      
                      rxData = SPIM_RXBUFFER[SPIM_rxBufferRead];
                                         
                      /* Enable Interrupt. */
                      SPIM_EnableRxInt();
                  
                  #else /* SPIM_RXBUFFERSIZE <= 4u */
 671   1          
 672   1              rxData = CY_GET_REG8(SPIM_RXDATA_PTR);
 673   1          
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 12  

 674   1          #endif /* SPIM_RXBUFFERSIZE > 4u */
 675   1      
 676   1              return (rxData);
 677   1          
 678   1      }
 679          
 680          
 681          /*******************************************************************************
 682          * Function Name: SPIM_GetRxBufferSize
 683          ********************************************************************************
 684          *
 685          * Summary:
 686          *  Returns the number of bytes/words of data currently held in the RX buffer.
 687          *  If RX Software Buffer not used then function return 0 if FIFO empty or 1 if 
 688          *  FIFO not empty. In another case function return size of RX Software Buffer.
 689          *
 690          * Parameters:
 691          *  None.
 692          *
 693          * Return:
 694          *  Integer count of the number of bytes/words in the RX buffer.
 695          *
 696          * Global variables:
 697          *  SPIM_rxBufferWrite - used for the account of the bytes which
 698          *  have been written down in the RX software buffer.
 699          *  SPIM_rxBufferRead - used for the account of the bytes which
 700          *  have been read from the RX software buffer.
 701          *
 702          * Side Effects:
 703          *  Clear status register of the component.
 704          *
 705          *******************************************************************************/
 706          uint8 SPIM_GetRxBufferSize(void) 
 707          {
 708   1          uint8 size = 0u;
 709   1      
 710   1          #if(SPIM_RXBUFFERSIZE > 4u)
                  
                      /* Disable Interrupt to protect variables that could change on interrupt. */
                      SPIM_DisableRxInt();
                  
                      if(SPIM_rxBufferRead == SPIM_rxBufferWrite)
                      {
                          size = 0u; /* No data in RX buffer */
                      }
                      else if(SPIM_rxBufferRead < SPIM_rxBufferWrite)
                      {
                          size = (SPIM_rxBufferWrite - SPIM_rxBufferRead);
                      }
                      else
                      {
                          size = (SPIM_RXBUFFERSIZE - SPIM_rxBufferRead) + SPIM_rxBufferWrite;
                      }
                  
                      /* Enable interrupt. */
                      SPIM_EnableRxInt();
                  
                  #else /* SPIM_RXBUFFERSIZE <= 4u */
 732   1          
 733   1              /* We can only know if there is data in the fifo. */
 734   1              size = ((SPIM_RX_STATUS_REG & SPIM_STS_RX_FIFO_NOT_EMPTY) == 
 735   1                       SPIM_STS_RX_FIFO_NOT_EMPTY) ? 1u : 0u;
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 13  

 736   1          
 737   1          #endif /* SPIM_RXBUFFERSIZE < 4u */
 738   1      
 739   1          return (size);
 740   1      }
 741          
 742          
 743          /*******************************************************************************
 744          * Function Name: SPIM_GetTxBufferSize
 745          ********************************************************************************
 746          *
 747          * Summary:
 748          *  Returns the number of bytes/words of data currently held in the TX buffer.
 749          *  If TX Software Buffer not used then function return 0 - if FIFO empty, 1 - if 
 750          *  FIFO not full, 4 - if FIFO full. In another case function return size of TX
 751          *  Software Buffer.
 752          *
 753          * Parameters:
 754          *  None.
 755          *
 756          * Return:
 757          *  Integer count of the number of bytes/words in the TX buffer.
 758          *
 759          * Global variables:
 760          *  SPIM_txBufferWrite - used for the account of the bytes which
 761          *  have been written down in the TX software buffer.
 762          *  SPIM_txBufferRead - used for the account of the bytes which
 763          *  have been read from the TX software buffer.
 764          *
 765          * Side Effects:
 766          *  Clear status register of the component.
 767          *
 768          *******************************************************************************/
 769          uint8  SPIM_GetTxBufferSize(void) 
 770          {
 771   1          uint8 size = 0u;
 772   1      
 773   1          #if(SPIM_TXBUFFERSIZE > 4u)
                  
                      /* Disable Interrupt to protect variables that could change on interrupt. */
                      SPIM_DisableTxInt();
                  
                      if(SPIM_txBufferRead == SPIM_txBufferWrite)
                      {
                          size = 0u;
                      }
                      else if(SPIM_txBufferRead < SPIM_txBufferWrite)
                      {
                          size = (SPIM_txBufferWrite - SPIM_txBufferRead);
                      }
                      else
                      {
                          size = (SPIM_TXBUFFERSIZE - SPIM_txBufferRead) + SPIM_txBufferWrite;
                      }
                  
                      /* Enable Interrupt. */
                      SPIM_EnableTxInt();
                  
                  #else /* SPIM_TXBUFFERSIZE <= 4u */
 795   1          
 796   1              size = SPIM_TX_STATUS_REG;
 797   1          
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 14  

 798   1              /* Is the fifo is full. */
 799   1              if((size & SPIM_STS_TX_FIFO_EMPTY) == SPIM_STS_TX_FIFO_EMPTY)
 800   1              {
 801   2                  size = 0u;
 802   2              }
 803   1              else if((size & SPIM_STS_TX_FIFO_NOT_FULL) == SPIM_STS_TX_FIFO_NOT_FULL)
 804   1              {
 805   2                  size = 1u;
 806   2              }
 807   1              else
 808   1              {
 809   2                  /* We only know there is data in the fifo. */
 810   2                  size = 4u;
 811   2              }
 812   1          
 813   1          #endif /* SPIM_TXBUFFERSIZE > 4u */
 814   1      
 815   1          return (size);
 816   1      }
 817          
 818          
 819          /*******************************************************************************
 820          * Function Name: SPIM_ClearRxBuffer
 821          ********************************************************************************
 822          *
 823          * Summary:
 824          *  Clear the RX RAM buffer by setting the read and write pointers both to zero.
 825          *
 826          * Parameters:
 827          *  None.
 828          *
 829          * Return:
 830          *  None.
 831          *
 832          * Global variables:
 833          *  SPIM_rxBufferWrite - used for the account of the bytes which
 834          *  have been written down in the RX software buffer, modified every function 
 835          *  call - resets to zero.
 836          *  SPIM_rxBufferRead - used for the account of the bytes which
 837          *  have been read from the RX software buffer, modified every function call -
 838          *  resets to zero.
 839          *
 840          * Theory:
 841          *  Setting the pointers to zero makes the system believe there is no data to 
 842          *  read and writing will resume at address 0 overwriting any data that may have
 843          *  remained in the RAM.
 844          *
 845          * Side Effects:
 846          *  Any received data not read from the RAM buffer will be lost when overwritten.
 847          *
 848          * Reentrant:
 849          *  No.
 850          *
 851          *******************************************************************************/
 852          void SPIM_ClearRxBuffer(void) 
 853          {
 854   1              /* Clear Hardware RX FIFO */
 855   1          while((!(SPIM_RX_STATUS_REG & SPIM_STS_RX_FIFO_NOT_EMPTY)) == 0u)
 856   1          {
 857   2              CY_GET_REG8(SPIM_RXDATA_PTR);
 858   2          }
 859   1              
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 15  

 860   1          #if(SPIM_RXBUFFERSIZE > 4u)
                  
                      /* Disable interrupt to protect variables that could change on interrupt. */        
                      SPIM_DisableRxInt();
                  
                      SPIM_rxBufferRead = 0u;
                      SPIM_rxBufferWrite = 0u;
                  
                      /* Enable Rx interrupt. */
                      SPIM_EnableRxInt();
                      
                  #endif /* SPIM_RXBUFFERSIZE > 4u */
 872   1      }
 873          
 874          
 875          /*******************************************************************************
 876          * Function Name: SPIM_ClearTxBuffer
 877          ********************************************************************************
 878          *
 879          * Summary:
 880          *  Clear the TX RAM buffer by setting the read and write pointers both to zero.
 881          *
 882          * Parameters:
 883          *  None.
 884          *
 885          * Return:
 886          *  None.
 887          *
 888          * Global variables:
 889          *  SPIM_txBufferWrite - used for the account of the bytes which
 890          *  have been written down in the TX software buffer, modified every function
 891          *  call - resets to zero.
 892          *  SPIM_txBufferRead - used for the account of the bytes which
 893          *  have been read from the TX software buffer, modified every function call -
 894          *  resets to zero.
 895          *
 896          * Theory:
 897          *  Setting the pointers to zero makes the system believe there is no data to 
 898          *  read and writing will resume at address 0 overwriting any data that may have
 899          *  remained in the RAM.
 900          *
 901          * Side Effects:
 902          *  Any data not yet transmitted from the RAM buffer will be lost when 
 903          *  overwritten.
 904          *
 905          * Reentrant:
 906          *  No.
 907          *
 908          *******************************************************************************/
 909          void SPIM_ClearTxBuffer(void) 
 910          {
 911   1          uint8 enableInterrupts = 0u;
 912   1          
 913   1          /* Clear Hardware TX FIFO */       
 914   1          enableInterrupts = CyEnterCriticalSection();
 915   1          
 916   1          #if(SPIM_DataWidth <= 8u)
 917   1          
 918   1              /* Clear TX FIFO */
 919   1              SPIM_AUX_CONTROL_DP0_REG |= SPIM_FIFO_CLR;
 920   1              SPIM_AUX_CONTROL_DP0_REG &= ~SPIM_FIFO_CLR;
 921   1          
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 16  

 922   1          #else
                  
                      /* Clear TX FIFO */
                      SPIM_AUX_CONTROL_DP0_REG |= SPIM_FIFO_CLR;
                      SPIM_AUX_CONTROL_DP0_REG &= ~SPIM_FIFO_CLR;
                      SPIM_AUX_CONTROL_DP1_REG |= SPIM_FIFO_CLR;
                      SPIM_AUX_CONTROL_DP1_REG &= ~SPIM_FIFO_CLR;
                      
                  #endif /* SPIM_DataWidth > 8u */
 931   1          
 932   1          CyExitCriticalSection(enableInterrupts);
 933   1              
 934   1          #if(SPIM_TXBUFFERSIZE > 4u)
                  
                      /* Disable Interrupt to protect variables that could change on interrupt. */
                      SPIM_DisableTxInt();
                  
                      SPIM_txBufferRead = 0u;
                      SPIM_txBufferWrite = 0u;
                  
                      /* If Buffer is empty then disable TX FIFO status interrupt */
                      SPIM_TX_STATUS_MASK_REG &= ~SPIM_STS_TX_FIFO_NOT_FULL;
              
                      /* Enable Interrupt. */
                      SPIM_EnableTxInt();
                  
                  #endif /* SPIM_TXBUFFERSIZE > 4u */
 949   1      }
 950          
 951          
 952          #if (SPIM_BidirectionalMode == 1u)
              
                  /*******************************************************************************
                  * Function Name: SPIM_TxEnable
                  ********************************************************************************
                  *
                  * Summary:
                  *  If the SPI master is configured to use a single bi-directional pin then this
                  *  will set the bi-directional pin to transmit.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void SPIM_TxEnable(void) 
                  {
                      SPIM_CONTROL_REG |= SPIM_CTRL_TX_SIGNAL_EN;
                  }
                  
                  
                  /*******************************************************************************
                  * Function Name: SPIM_TxDisable
                  ********************************************************************************
                  *
                  * Summary:
                  *  If the SPI master is configured to use a single bi-directional pin then this
                  *  will set the bi-directional pin to receive.
                  *
                  * Parameters:
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 17  

                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void SPIM_TxDisable(void) 
                  {
                      SPIM_CONTROL_REG &= ~SPIM_CTRL_TX_SIGNAL_EN;
                  }
                  
              #endif /* SPIM_BidirectionalMode == 1u */
 996          
 997          
 998          /*******************************************************************************
 999          * Function Name: SPIM_PutArray
1000          ********************************************************************************                       
1001          *
1002          * Summary:
1003          *  Write available data from ROM/RAM to the TX buffer while space is available 
1004          *  in the TX buffer. Keep trying until all data is passed to the TX buffer.
1005          *
1006          * Parameters:
1007          *  *buffer: Pointer to the location in RAM containing the data to send
1008          *  byteCount: The number of bytes to move to the transmit buffer.
1009          *
1010          * Return:
1011          *  None.
1012          *
1013          * Side Effects:
1014          *  Will stay in this routine until all data has been sent.  May get locked in
1015          *  this loop if data is not being initiated by the master if there is not
1016          *  enough room in the TX FIFO.
1017          *
1018          * Reentrant:
1019          *  No.
1020          *
1021          *******************************************************************************/
1022          void SPIM_PutArray(uint8 *buffer, uint8 byteCount) 
1023          {
1024   1          while(byteCount > 0u)
1025   1          {
1026   2              SPIM_WriteTxData(*buffer++);
1027   2              byteCount--;
1028   2          }
1029   1      }
1030          
1031          
1032          /*******************************************************************************
1033          * Function Name: SPIM_ClearFIFO
1034          ********************************************************************************
1035          *
1036          * Summary:
1037          *  Clear the RX and TX FIFO's of all data for a fresh start.
1038          *
1039          * Parameters:
1040          *  None.
1041          *
1042          * Return:
1043          *  None.
1044          *
1045          * Side Effects:
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 18  

1046          *  Clear status register of the component.
1047          *
1048          *******************************************************************************/
1049          void SPIM_ClearFIFO(void) 
1050          {
1051   1          uint8 enableInterrupts = 0u;
1052   1          
1053   1          while((!(SPIM_RX_STATUS_REG & SPIM_STS_RX_FIFO_NOT_EMPTY)) == 0u)
1054   1          {
1055   2              CY_GET_REG8(SPIM_RXDATA_PTR);
1056   2          }
1057   1          
1058   1          enableInterrupts = CyEnterCriticalSection();
1059   1          
1060   1          #if(SPIM_DataWidth <= 8u)
1061   1          
1062   1              /* Clear TX FIFO */
1063   1              SPIM_AUX_CONTROL_DP0_REG |= SPIM_FIFO_CLR;
1064   1              SPIM_AUX_CONTROL_DP0_REG &= ~SPIM_FIFO_CLR;
1065   1          
1066   1          #else
                  
                      /* Clear TX FIFO */
                      SPIM_AUX_CONTROL_DP0_REG |= SPIM_FIFO_CLR;
                      SPIM_AUX_CONTROL_DP0_REG &= ~SPIM_FIFO_CLR;
                      SPIM_AUX_CONTROL_DP1_REG |= SPIM_FIFO_CLR;
                      SPIM_AUX_CONTROL_DP1_REG &= ~SPIM_FIFO_CLR;
                      
                  #endif /* SPIM_DataWidth > 8u */
1075   1          
1076   1          CyExitCriticalSection(enableInterrupts);
1077   1      }
1078          
1079          
1080          /* Following functions are for version Compatibility, they are obsolete.
1081          *  Please do not use it in new projects.
1082          */
1083          
1084          /*******************************************************************************
1085          * Function Name: SPIM_EnableInt
1086          ********************************************************************************
1087          *
1088          * Summary:
1089          *  Enable internal interrupt generation.
1090          *
1091          * Parameters:
1092          *  None.
1093          *
1094          * Return:
1095          *  None.
1096          *
1097          * Theory:
1098          *  Enable the internal interrupt output -or- the interrupt component itself.
1099          *
1100          *******************************************************************************/
1101          void SPIM_EnableInt(void) 
1102          {       
1103   1          #if(SPIM_InternalTxInterruptEnabled)    
                      CyIntEnable(SPIM_TX_ISR_NUMBER);
                  #endif /* SPIM_InternalTxInterruptEnabled */                                
1106   1          
1107   1          #if(SPIM_InternalRxInterruptEnabled)           
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 19  

                      CyIntEnable(SPIM_RX_ISR_NUMBER);
                  #endif /* SPIM_InternalRxInterruptEnabled */     
1110   1      }
1111          
1112          
1113          /*******************************************************************************
1114          * Function Name: SPIM_DisableInt
1115          ********************************************************************************
1116          *
1117          * Summary:
1118          *  Disable internal interrupt generation.
1119          *
1120          * Parameters:
1121          *  None.
1122          *
1123          * Return:
1124          *  None.
1125          *
1126          * Theory:
1127          *  Disable the internal interrupt output -or- the interrupt component itself.
1128          *
1129          *******************************************************************************/
1130          void SPIM_DisableInt(void) 
1131          {
1132   1          #if(SPIM_InternalTxInterruptEnabled)    
                      CyIntDisable(SPIM_TX_ISR_NUMBER);
                  #endif /* SPIM_InternalTxInterruptEnabled */
1135   1          
1136   1          #if(SPIM_InternalRxInterruptEnabled)           
                      CyIntDisable(SPIM_RX_ISR_NUMBER);
                  #endif /* SPIM_InternalRxInterruptEnabled */
1139   1      }
1140          
1141          
1142          /*******************************************************************************
1143          * Function Name: SPIM_SetInterruptMode
1144          ********************************************************************************
1145          *
1146          * Summary:
1147          *  Configure which status bits trigger an interrupt event.
1148          *
1149          * Parameters:
1150          *  intSrc: An or'd combination of the desired status bit masks (defined in the 
1151          *  header file).
1152          *
1153          * Return:
1154          *  None.
1155          *
1156          * Theory:
1157          *  Enables the output of specific status bits to the interrupt controller.
1158          *
1159          *******************************************************************************/
1160          void SPIM_SetInterruptMode(uint8 intSrc) 
1161          {
1162   1          SPIM_TX_STATUS_MASK_REG  = intSrc & ~(1u << SPIM_STS_SPI_IDLE_SHIFT);
1163   1          SPIM_RX_STATUS_MASK_REG  = intSrc;
1164   1      }
1165          
1166          
1167          /*******************************************************************************
1168          * Function Name: SPIM_ReadStatus
1169          ********************************************************************************
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 20  

1170          *
1171          * Summary:
1172          *  Read the status register for the component.
1173          *
1174          * Parameters:
1175          *  None.
1176          *
1177          * Return:
1178          *  Contents of the status register.
1179          *
1180          * Global variables:
1181          *  SPIM_swStatus - used to store in software status register, 
1182          *  modified every function call - resets to zero.
1183          *
1184          * Theory:
1185          *  Allows the user and the API to read the status register for error detection
1186          *  and flow control.
1187          *
1188          * Side Effects:
1189          *  Clear status register of the component.
1190          *
1191          * Reentrant:
1192          *  No.
1193          *
1194          *******************************************************************************/
1195          uint8 SPIM_ReadStatus(void) 
1196          {
1197   1          uint8 tmpStatus;
1198   1              
1199   1          #if ((SPIM_TXBUFFERSIZE > 4u) || (SPIM_RXBUFFERSIZE > 4u))
                  
                      SPIM_DisableInt();
                      
                      tmpStatus = (SPIM_GET_STATUS_TX(SPIM_swStatusTx) & 
                                    ~(1u << SPIM_STS_SPI_IDLE_SHIFT)) | 
                                    SPIM_GET_STATUS_RX(SPIM_swStatusRx);
                      
                      SPIM_swStatusTx = 0u;
                      SPIM_swStatusRx = 0u;
                      
                      /* Enable Interrupts */
                      SPIM_EnableInt();
                      
                  #else /* (SPIM_TXBUFFERSIZE < 4u) && (SPIM_RXBUFFERSIZE < 4u) */
1214   1          
1215   1              tmpStatus = (SPIM_TX_STATUS_REG & ~(1u << SPIM_STS_SPI_IDLE_SHIFT)) |
1216   1                           SPIM_RX_STATUS_REG;
1217   1              
1218   1          #endif /* (SPIM_TXBUFFERSIZE > 4u) || (SPIM_RXBUFFERSIZE > 4u) */
1219   1          
1220   1          return(tmpStatus);
1221   1      }
1222          
1223          
1224          /* [] END OF FILE */
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 21  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION SPIM_Init (BEGIN)
                                           ; SOURCE LINE # 72
                                           ; SOURCE LINE # 73
                                           ; SOURCE LINE # 75
0000 906481            MOV     DPTR,#06481H
0003 740F              MOV     A,#0FH
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 103
0006 120000      R     LCALL   SPIM_ClearFIFO
                                           ; SOURCE LINE # 119
0009 120000      R     LCALL   SPIM_ReadTxStatus
                                           ; SOURCE LINE # 120
000C 120000      R     LCALL   SPIM_ReadRxStatus
                                           ; SOURCE LINE # 127
000F 906483            MOV     DPTR,#06483H
0012 E4                CLR     A
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
0014 906482            MOV     DPTR,#06482H
0017 E4                CLR     A
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 131
0019         ?C0001:
0019 22                RET     
             ; FUNCTION SPIM_Init (END)

             ; FUNCTION SPIM_Enable (BEGIN)
                                           ; SOURCE LINE # 148
                                           ; SOURCE LINE # 149
                                           ; SOURCE LINE # 150
0000 900000      R     MOV     DPTR,#enableInterrupts
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 152
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#enableInterrupts
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
000D 906491            MOV     DPTR,#06491H
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 4420              ORL     A,#020H
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 155
0018 906493            MOV     DPTR,#06493H
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 4410              ORL     A,#010H
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 156
0023 906492            MOV     DPTR,#06492H
0026 E0                MOVX    A,@DPTR
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 22  

0027 FF                MOV     R7,A
0028 EF                MOV     A,R7
0029 4410              ORL     A,#010H
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 158
002E 900000      R     MOV     DPTR,#enableInterrupts
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 161
0036 120000      E     LCALL   SPIM_IntClock_Start
                                           ; SOURCE LINE # 171
0039         ?C0002:
0039 22                RET     
             ; FUNCTION SPIM_Enable (END)

             ; FUNCTION SPIM_Start (BEGIN)
                                           ; SOURCE LINE # 198
                                           ; SOURCE LINE # 199
                                           ; SOURCE LINE # 200
0000 900000      R     MOV     DPTR,#SPIM_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0003
                                           ; SOURCE LINE # 201
                                           ; SOURCE LINE # 202
0008 120000      R     LCALL   SPIM_Init
                                           ; SOURCE LINE # 203
000B 900000      R     MOV     DPTR,#SPIM_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 204
0011         ?C0003:
                                           ; SOURCE LINE # 206
0011 120000      R     LCALL   SPIM_Enable
                                           ; SOURCE LINE # 207
0014         ?C0004:
0014 22                RET     
             ; FUNCTION SPIM_Start (END)

             ; FUNCTION SPIM_Stop (BEGIN)
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 229
0000 900000      R     MOV     DPTR,#enableInterrupts
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 231
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#enableInterrupts
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 233
000D 906493            MOV     DPTR,#06493H
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 54EF              ANL     A,#0EFH
0015 FF                MOV     R7,A
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 23  

0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 234
0018 906492            MOV     DPTR,#06492H
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 54EF              ANL     A,#0EFH
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 236
0023 900000      R     MOV     DPTR,#enableInterrupts
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 239
002B 120000      E     LCALL   SPIM_IntClock_Stop
                                           ; SOURCE LINE # 249
002E         ?C0005:
002E 22                RET     
             ; FUNCTION SPIM_Stop (END)

             ; FUNCTION SPIM_EnableTxInt (BEGIN)
                                           ; SOURCE LINE # 269
                                           ; SOURCE LINE # 270
                                           ; SOURCE LINE # 274
0000         ?C0006:
0000 22                RET     
             ; FUNCTION SPIM_EnableTxInt (END)

             ; FUNCTION SPIM_EnableRxInt (BEGIN)
                                           ; SOURCE LINE # 294
                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 299
0000         ?C0007:
0000 22                RET     
             ; FUNCTION SPIM_EnableRxInt (END)

             ; FUNCTION SPIM_DisableTxInt (BEGIN)
                                           ; SOURCE LINE # 319
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 324
0000         ?C0008:
0000 22                RET     
             ; FUNCTION SPIM_DisableTxInt (END)

             ; FUNCTION SPIM_DisableRxInt (BEGIN)
                                           ; SOURCE LINE # 344
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 349
0000         ?C0009:
0000 22                RET     
             ; FUNCTION SPIM_DisableRxInt (END)

             ; FUNCTION _SPIM_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 370
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 371
                                           ; SOURCE LINE # 372
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 24  

0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906483            MOV     DPTR,#06483H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 373
000F         ?C0010:
000F 22                RET     
             ; FUNCTION _SPIM_SetTxInterruptMode (END)

             ; FUNCTION _SPIM_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 394
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 395
                                           ; SOURCE LINE # 396
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906482            MOV     DPTR,#06482H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 397
000F         ?C0011:
000F 22                RET     
             ; FUNCTION _SPIM_SetRxInterruptMode (END)

             ; FUNCTION SPIM_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 428
                                           ; SOURCE LINE # 429
                                           ; SOURCE LINE # 430
0000 900000      R     MOV     DPTR,#tmpStatus
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 445
0005 906463            MOV     DPTR,#06463H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#tmpStatus
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 449
000F 900000      R     MOV     DPTR,#tmpStatus
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 450
0014         ?C0012:
0014 22                RET     
             ; FUNCTION SPIM_ReadTxStatus (END)

             ; FUNCTION SPIM_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 481
                                           ; SOURCE LINE # 482
                                           ; SOURCE LINE # 483
0000 900000      R     MOV     DPTR,#tmpStatus
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 498
0005 906462            MOV     DPTR,#06462H
0008 E0                MOVX    A,@DPTR
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 25  

0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#tmpStatus
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 502
000F 900000      R     MOV     DPTR,#tmpStatus
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 503
0014         ?C0013:
0014 22                RET     
             ; FUNCTION SPIM_ReadRxStatus (END)

             ; FUNCTION _SPIM_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 540
0000 900000      R     MOV     DPTR,#txData
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 541
0005         ?C0014:
                                           ; SOURCE LINE # 597
0005 906463            MOV     DPTR,#06463H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5404              ANL     A,#04H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 60F1              JZ      ?C0014
0014         ?C0015:
                                           ; SOURCE LINE # 600
0014 900000      R     MOV     DPTR,#txData
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
0019 906441            MOV     DPTR,#06441H
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 603
001E         ?C0016:
001E 22                RET     
             ; FUNCTION _SPIM_WriteTxData (END)

             ; FUNCTION SPIM_ReadRxData (BEGIN)
                                           ; SOURCE LINE # 640
                                           ; SOURCE LINE # 641
                                           ; SOURCE LINE # 642
0000 900000      R     MOV     DPTR,#rxData
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 672
0005 906451            MOV     DPTR,#06451H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#rxData
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 676
000F 900000      R     MOV     DPTR,#rxData
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 26  

                                           ; SOURCE LINE # 678
0014         ?C0017:
0014 22                RET     
             ; FUNCTION SPIM_ReadRxData (END)

             ; FUNCTION SPIM_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 706
                                           ; SOURCE LINE # 707
                                           ; SOURCE LINE # 708
0000 900000      R     MOV     DPTR,#size
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 734
0005 906462            MOV     DPTR,#06462H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5420              ANL     A,#020H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 6420              XRL     A,#020H
0013 4E                ORL     A,R6
0014 7004              JNZ     ?C0018
0016 7F01              MOV     R7,#01H
0018 8002              SJMP    ?C0019
001A         ?C0018:
001A 7F00              MOV     R7,#00H
001C         ?C0019:
001C 900000      R     MOV     DPTR,#size
001F EF                MOV     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 739
0021 900000      R     MOV     DPTR,#size
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
                                           ; SOURCE LINE # 740
0026         ?C0020:
0026 22                RET     
             ; FUNCTION SPIM_GetRxBufferSize (END)

             ; FUNCTION SPIM_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 769
                                           ; SOURCE LINE # 770
                                           ; SOURCE LINE # 771
0000 900000      R     MOV     DPTR,#size
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 796
0005 906463            MOV     DPTR,#06463H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#size
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 799
000F 900000      R     MOV     DPTR,#size
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 5402              ANL     A,#02H
0017 FF                MOV     R7,A
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 27  

0018 7E00              MOV     R6,#00H
001A EF                MOV     A,R7
001B 6402              XRL     A,#02H
001D 4E                ORL     A,R6
001E 7007              JNZ     ?C0021
                                           ; SOURCE LINE # 800
                                           ; SOURCE LINE # 801
0020 900000      R     MOV     DPTR,#size
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 802
0025 801F              SJMP    ?C0022
0027         ?C0021:
                                           ; SOURCE LINE # 803
0027 900000      R     MOV     DPTR,#size
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 5404              ANL     A,#04H
002F FF                MOV     R7,A
0030 7E00              MOV     R6,#00H
0032 EF                MOV     A,R7
0033 6404              XRL     A,#04H
0035 4E                ORL     A,R6
0036 7008              JNZ     ?C0023
                                           ; SOURCE LINE # 804
                                           ; SOURCE LINE # 805
0038 900000      R     MOV     DPTR,#size
003B 7401              MOV     A,#01H
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 806
003E 8006              SJMP    ?C0022
0040         ?C0023:
                                           ; SOURCE LINE # 808
                                           ; SOURCE LINE # 810
0040 900000      R     MOV     DPTR,#size
0043 7404              MOV     A,#04H
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 811
0046         ?C0024:
0046         ?C0022:
                                           ; SOURCE LINE # 815
0046 900000      R     MOV     DPTR,#size
0049 E0                MOVX    A,@DPTR
004A FF                MOV     R7,A
                                           ; SOURCE LINE # 816
004B         ?C0025:
004B 22                RET     
             ; FUNCTION SPIM_GetTxBufferSize (END)

             ; FUNCTION SPIM_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 852
                                           ; SOURCE LINE # 853
0000         ?C0026:
                                           ; SOURCE LINE # 855
0000 906462            MOV     DPTR,#06462H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 5420              ANL     A,#020H
0008 FF                MOV     R7,A
0009 7E00              MOV     R6,#00H
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 28  

000B EF                MOV     A,R7
000C 4E                ORL     A,R6
000D 7004              JNZ     ?C0028
000F 7F01              MOV     R7,#01H
0011 8002              SJMP    ?C0029
0013         ?C0028:
0013 7F00              MOV     R7,#00H
0015         ?C0029:
0015 EF                MOV     A,R7
0016 7007              JNZ     ?C0030
                                           ; SOURCE LINE # 856
                                           ; SOURCE LINE # 857
0018 906451            MOV     DPTR,#06451H
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
                                           ; SOURCE LINE # 858
001D 80E1              SJMP    ?C0026
001F         ?C0027:
                                           ; SOURCE LINE # 872
001F         ?C0030:
001F 22                RET     
             ; FUNCTION SPIM_ClearRxBuffer (END)

             ; FUNCTION SPIM_ClearTxBuffer (BEGIN)
                                           ; SOURCE LINE # 909
                                           ; SOURCE LINE # 910
                                           ; SOURCE LINE # 911
0000 900000      R     MOV     DPTR,#enableInterrupts
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 914
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#enableInterrupts
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 919
000D 906491            MOV     DPTR,#06491H
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 4403              ORL     A,#03H
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 920
0018 906491            MOV     DPTR,#06491H
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 54FC              ANL     A,#0FCH
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 932
0023 900000      R     MOV     DPTR,#enableInterrupts
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 949
002B         ?C0031:
002B 22                RET     
             ; FUNCTION SPIM_ClearTxBuffer (END)
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 29  


             ; FUNCTION _SPIM_PutArray (BEGIN)
                                           ; SOURCE LINE # 1022
0000 900000      R     MOV     DPTR,#buffer
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1023
000B         ?C0032:
                                           ; SOURCE LINE # 1024
000B 900000      R     MOV     DPTR,#byteCount
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 D3                SETB    C
0012 9400              SUBB    A,#00H
0014 4019              JC      ?C0034
                                           ; SOURCE LINE # 1025
                                           ; SOURCE LINE # 1026
0016 900000      R     MOV     DPTR,#buffer
0019 E4                CLR     A
001A 75F001            MOV     B,#01H
001D 120000      E     LCALL   ?C?PLDIXDATA
0020 120000      E     LCALL   ?C?CLDPTR
0023 FF                MOV     R7,A
0024 120000      R     LCALL   _SPIM_WriteTxData
                                           ; SOURCE LINE # 1027
0027 900000      R     MOV     DPTR,#byteCount
002A E0                MOVX    A,@DPTR
002B 14                DEC     A
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1028
002D 80DC              SJMP    ?C0032
002F         ?C0033:
                                           ; SOURCE LINE # 1029
002F         ?C0034:
002F 22                RET     
             ; FUNCTION _SPIM_PutArray (END)

             ; FUNCTION SPIM_ClearFIFO (BEGIN)
                                           ; SOURCE LINE # 1049
                                           ; SOURCE LINE # 1050
                                           ; SOURCE LINE # 1051
0000 900000      R     MOV     DPTR,#enableInterrupts
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
0005         ?C0035:
                                           ; SOURCE LINE # 1053
0005 906462            MOV     DPTR,#06462H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5420              ANL     A,#020H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 7004              JNZ     ?C0037
0014 7F01              MOV     R7,#01H
0016 8002              SJMP    ?C0038
0018         ?C0037:
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 30  

0018 7F00              MOV     R7,#00H
001A         ?C0038:
001A EF                MOV     A,R7
001B 7007              JNZ     ?C0036
                                           ; SOURCE LINE # 1054
                                           ; SOURCE LINE # 1055
001D 906451            MOV     DPTR,#06451H
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
                                           ; SOURCE LINE # 1056
0022 80E1              SJMP    ?C0035
0024         ?C0036:
                                           ; SOURCE LINE # 1058
0024 120000      E     LCALL   CyEnterCriticalSection
0027 900000      R     MOV     DPTR,#enableInterrupts
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1063
002C 906491            MOV     DPTR,#06491H
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 EF                MOV     A,R7
0032 4403              ORL     A,#03H
0034 FF                MOV     R7,A
0035 EF                MOV     A,R7
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1064
0037 906491            MOV     DPTR,#06491H
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C EF                MOV     A,R7
003D 54FC              ANL     A,#0FCH
003F FF                MOV     R7,A
0040 EF                MOV     A,R7
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1076
0042 900000      R     MOV     DPTR,#enableInterrupts
0045 E0                MOVX    A,@DPTR
0046 FF                MOV     R7,A
0047 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1077
004A         ?C0039:
004A 22                RET     
             ; FUNCTION SPIM_ClearFIFO (END)

             ; FUNCTION SPIM_EnableInt (BEGIN)
                                           ; SOURCE LINE # 1101
                                           ; SOURCE LINE # 1102
                                           ; SOURCE LINE # 1110
0000         ?C0040:
0000 22                RET     
             ; FUNCTION SPIM_EnableInt (END)

             ; FUNCTION SPIM_DisableInt (BEGIN)
                                           ; SOURCE LINE # 1130
                                           ; SOURCE LINE # 1131
                                           ; SOURCE LINE # 1139
0000         ?C0041:
0000 22                RET     
             ; FUNCTION SPIM_DisableInt (END)

             ; FUNCTION _SPIM_SetInterruptMode (BEGIN)
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 31  

                                           ; SOURCE LINE # 1160
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1161
                                           ; SOURCE LINE # 1162
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 54EF              ANL     A,#0EFH
000D FF                MOV     R7,A
000E 906483            MOV     DPTR,#06483H
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1163
0013 900000      R     MOV     DPTR,#intSrc
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 906482            MOV     DPTR,#06482H
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1164
001D         ?C0042:
001D 22                RET     
             ; FUNCTION _SPIM_SetInterruptMode (END)

             ; FUNCTION SPIM_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1195
                                           ; SOURCE LINE # 1196
                                           ; SOURCE LINE # 1216
0000 906463            MOV     DPTR,#06463H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 54EF              ANL     A,#0EFH
0008 FF                MOV     R7,A
0009 906462            MOV     DPTR,#06462H
000C E0                MOVX    A,@DPTR
000D FE                MOV     R6,A
000E EF                MOV     A,R7
000F 4E                ORL     A,R6
0010 FF                MOV     R7,A
0011 900000      R     MOV     DPTR,#tmpStatus
0014 EF                MOV     A,R7
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1220
0016 900000      R     MOV     DPTR,#tmpStatus
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
                                           ; SOURCE LINE # 1221
001B         ?C0043:
001B 22                RET     
             ; FUNCTION SPIM_ReadStatus (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    656    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     19    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.03   SPIM                                                                  07/02/2012 19:47:01 PAGE 32  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
